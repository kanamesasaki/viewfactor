/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/fragment-shader.glsl.ts":
/*!*************************************!*\
  !*** ./src/fragment-shader.glsl.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragment: () => (/* binding */ fragment)\n/* harmony export */ });\nconst fragment = `#version 300 es\nprecision highp float;\n\nvoid main() {}`;\n\n\n//# sourceURL=webpack://viewfactor/./src/fragment-shader.glsl.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFragmentShader: () => (/* binding */ getFragmentShader),\n/* harmony export */   getVertexShader: () => (/* binding */ getVertexShader)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.glsl */ \"./src/vertex-shader.glsl.ts\");\n/* harmony import */ var _fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fragment-shader.glsl */ \"./src/fragment-shader.glsl.ts\");\n\n\n// Extract the content's of a shader script from the JavaScript file \n// Return the compiled shader\nfunction getVertexShader(gl) {\n    let shader;\n    shader = gl.createShader(gl.VERTEX_SHADER);\n    if (shader === null) {\n        throw new Error('Could not create vertex shader');\n    }\n    gl.shaderSource(shader, _vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_0__.vertex);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(shader));\n        return null;\n    }\n    return shader;\n}\n// Extract the content's of a shader script from the JavaScript file \n// Return the compiled shader\nfunction getFragmentShader(gl) {\n    let shader;\n    shader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (shader === null) {\n        throw new Error('Could not create fragment shader');\n    }\n    gl.shaderSource(shader, _fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_1__.fragment);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(shader));\n        return null;\n    }\n    return shader;\n}\n\n\n//# sourceURL=webpack://viewfactor/./src/utils.ts?");

/***/ }),

/***/ "./src/vertex-shader.glsl.ts":
/*!***********************************!*\
  !*** ./src/vertex-shader.glsl.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertex: () => (/* binding */ vertex)\n/* harmony export */ });\nconst vertex = `#version 300 es\nprecision highp float;\n\nin float iSeed;\nout float oCalc;\n\n// Calculation case\nuniform int uCase;\n// 0: dsToDisk\n// 1: dsToDiskOffsetParallel\n// 2: dsToDiskOffsetVertical\n// 3: dsToRectParallel\n// 4: dsToRectVertical\n// 5: dsToSphere\n// 6: dsToCylinder\n// 7: dsToTriangle\n\n// 10: diskToDisk\n// 11: diskToCylinder\n// 20: rectToRectParallel\n// 21: rectToRectVertical\n// 30: sphereToRect\n// 31: sphereToDisk\n// 32: sphereToCylinder\n// 33: spehreToCone\n// 40: cylinderToCylinder\n// 50: coneToDisk\n\n// 100: triToTriArbitrary\n// 101: rectTorectArbitrary\n\nuniform float uR;\nuniform float uH;\nuniform float uTheta;\nuniform float uA;\nuniform float uB;\nuniform float uC;\nuniform float uR1;\nuniform float uR2;\nuniform float uL;\nuniform float uL1;\nuniform float uL2;\nuniform float uW;\nuniform float uTest;\n\nconst float PI = 3.141592653589793238462643383;\n\n// MRG32k3a parameters\nuint[3] x1 = uint[3](0u, 0u, 1234567u);\nuint[3] x2 = uint[3](0u, 0u, 1234567u);\nconst uint[9] a1 = uint[9](0u, 1u, 0u, 0u, 0u, 1u, 4294156359u, 1403580u, 0u);\nconst uint[9] a2 = uint[9](0u, 1u, 0u, 0u, 0u, 1u, 4293573854u, 0u, 527612u);\nconst uint m1 = 4294967087u;\nconst uint m2 = 4294944443u;\nconst uint a11 = 1403580u;\nconst uint a10 = 810728u;\nconst uint a22 = 527612u;\nconst uint a20 = 1370589u;\n\nuint addModM(uint a, uint b, uint m) {\n    uint amodm = a % m;\n    uint bmodm = b % m;\n    uint blim = m - amodm;\n    if (bmodm <= blim) {\n        return amodm + bmodm; \n    }\n    else {\n        return amodm - (m - bmodm);\n    }\n}\n\nuint diffModM(uint a, uint b, uint m) {\n    uint amodm = a % m;\n    uint bmodm = b % m;\n    if (amodm >= bmodm) {\n        return amodm - bmodm;\n    }\n    else {\n        return amodm + (m - bmodm);\n    }\n}\n\nuint multModM(uint a, uint b, uint m) {\n    uint amodm = a % m;\n    uint bmodm = b % m;\n    uint res = 0u;\n    while (bmodm > 0u) {\n        if ((bmodm&0x1u) == 0x1u) {\n            res = addModM(res, amodm, m);\n        }\n        bmodm = bmodm >> 1;\n        amodm = addModM(amodm, amodm, m);\n    }\n    return res;\n}\n\n// calculate c = a*b mod m\nvoid matMultModM(uint[9] a, uint[9] b, uint m, out uint[9] c) {\n    c[0] = addModM(addModM(multModM(a[0],b[0],m), multModM(a[1],b[3],m), m), multModM(a[2],b[6],m), m);\n    c[1] = addModM(addModM(multModM(a[0],b[1],m), multModM(a[1],b[4],m), m), multModM(a[2],b[7],m), m);\n    c[2] = addModM(addModM(multModM(a[0],b[2],m), multModM(a[1],b[5],m), m), multModM(a[2],b[8],m), m);\n    c[3] = addModM(addModM(multModM(a[3],b[0],m), multModM(a[4],b[3],m), m), multModM(a[5],b[6],m), m);\n    c[4] = addModM(addModM(multModM(a[3],b[1],m), multModM(a[4],b[4],m), m), multModM(a[5],b[7],m), m);\n    c[5] = addModM(addModM(multModM(a[3],b[2],m), multModM(a[4],b[5],m), m), multModM(a[5],b[8],m), m);\n    c[6] = addModM(addModM(multModM(a[6],b[0],m), multModM(a[7],b[3],m), m), multModM(a[8],b[6],m), m);\n    c[7] = addModM(addModM(multModM(a[6],b[1],m), multModM(a[7],b[4],m), m), multModM(a[8],b[7],m), m);\n    c[8] = addModM(addModM(multModM(a[6],b[2],m), multModM(a[7],b[5],m), m), multModM(a[8],b[8],m), m);\n}\n\n// calculate w = a*v mod m\nvoid matVecMultModM(uint[9] a, uint[3] v, uint m, out uint[3] w) {\n    w[0] = addModM(addModM(multModM(a[0],v[0],m), multModM(a[1],v[1],m), m), multModM(a[2],v[2],m), m);\n    w[1] = addModM(addModM(multModM(a[3],v[0],m), multModM(a[4],v[1],m), m), multModM(a[5],v[2],m), m);\n    w[2] = addModM(addModM(multModM(a[6],v[0],m), multModM(a[7],v[1],m), m), multModM(a[8],v[2],m), m);\n}\n\n// calculate c = a+b mod m\nvoid matVecMultModM(uint[3] a, uint[3] b, uint m, out uint[9] c) {\n    c[0] = addModM(a[0], b[0], m);\n    c[1] = addModM(a[1], b[1], m);\n    c[2] = addModM(a[2], b[2], m);\n}\n\n// calculate b = a**n mod m\nvoid matPowModM(uint[9] a, uint n, uint m, out uint[9] b) {\n    uint[9] apow = a;\n    b = uint[9](1u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 1u);\n    while (n > 0u) {\n        if ((n&0x1u) == 0x1u) {\n            matMultModM(apow, b, m, b);\n        }\n        n = n >> 1;\n        matMultModM(apow, apow, m, apow);\n    }\n}\n\nuint stepMRG32k3a(void) {\n    uint x1i = diffModM(multModM(x1[1], a11, m1), multModM(x1[0], a10, m1), m1);\n    uint x2i = diffModM(multModM(x2[2], a22, m2), multModM(x2[0], a20, m2), m2);\n    x1[0] = x1[1];\n    x1[1] = x1[2];\n    x1[2] = x1i;\n    x2[0] = x2[1];\n    x2[1] = x2[2];\n    x2[2] = x2i;\n    return diffModM(x1i, x2i, m1);\n}\n\nfloat floatMRG32k3a(void) {\n    return float(stepMRG32k3a())*(1.0/4294967086.0);\n}\n\nuint skipMRG32k3a(uint n) {\n    uint[9] a1pow;\n    uint[9] a2pow;\n    matPowModM(a1, n, m1, a1pow);\n    matPowModM(a2, n, m2, a2pow);\n    matVecMultModM(a1pow, x1, m1, x1);\n    matVecMultModM(a2pow, x2, m2, x2);\n    return diffModM(x1[0], x2[0], m1);\n}\n\nuniform struct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nuniform struct Intersection {\n    float dist;\n    int id;\n};\n\nuniform struct Disk {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    float radius;\n};\n\nuniform struct Rectangle {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nuniform struct Triangle {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nuniform struct Sphere {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    float radius;\n};\n\nuniform struct Cylinder {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    float radius;\n};\n\nuniform struct Cone {\n    int id;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    float radius1;\n    float radius2;\n};\n\nIntersection toDisk(Disk s, Ray ray) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    if (dot(Rz, ray.rd) == 0.0) {\n        return p;\n    }\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = transpose(Rmat);\n    vec3 Ro = Rinv * (ray.ro - s.p1);\n    vec3 Rd = Rinv * ray.rd;\n    float t = -Ro[2]/Rd[2];\n    if (t <= 0.0) {\n        return p;\n    }\n    vec3 pLocal = Ro + Rd * t;\n    float dist = pLocal[0]*pLocal[0] + pLocal[1]*pLocal[1];\n    if (dist < s.radius*s.radius) {\n        p.id = s.id;\n        p.dist = t;\n    }\n    return p;\n}\n\nIntersection toRect(Rectangle s, Ray ray) {\n    vec3 Ry = normalize(s.p3 - s.p1);\n    vec3 Rx = normalize(s.p2 - s.p1);\n    vec3 Rz = cross(Rx, Ry);\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    if (dot(Rz, ray.rd) == 0.0) {\n        return p;\n    }\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = transpose(Rmat);\n    vec3 Ro = Rinv * (ray.ro - s.p1);\n    vec3 Rd = Rinv * ray.rd;\n    float t = -Ro[2]/Rd[2];\n    if (t <= 0.0) {\n        return p;\n    }\n    vec3 pLocal = Ro + Rd * t;\n    if (0.0 <= pLocal[0] && pLocal[0] <= length(s.p2 - s.p1) && 0.0 <= pLocal[1] && pLocal[1] <= length(s.p3 - s.p1)) {\n        p.id = s.id;\n        p.dist = t;\n    }\n    return p;\n}\n\nIntersection toTriangle(Triangle s, Ray ray) {\n    vec3 Ry = s.p3 - s.p1;\n    vec3 Rx = s.p2 - s.p1;\n    vec3 Rz = cross(Rx, Ry);\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    if (dot(Rz, ray.rd) == 0.0) {\n        return p;\n    }\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = inverse(Rmat);\n    vec3 Ro = Rinv * (ray.ro - s.p1);\n    vec3 Rd = Rinv * ray.rd;\n    float t = -Ro[2]/Rd[2];\n    if (t <= 0.0) {\n        return p;\n    }\n    vec3 pLocal = Ro + Rd * t;\n    if (0.0 <= pLocal[0] && pLocal[0] <= 1.0 && 0.0 <= pLocal[1] && pLocal[1] <= 1.0 && 0.0 <= pLocal[0] + pLocal[1] && pLocal[0] + pLocal[1] <= 1.0) {\n        p.id = s.id;\n        p.dist = t;\n    }\n    return p;\n}\n\nIntersection toSphere(Sphere s, Ray ray) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = transpose(Rmat);\n    vec3 Ro = Rinv * (ray.ro - s.p1);\n    vec3 Rd = Rinv * ray.rd;\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    float a = dot(Rd, Rd);\n    float b = dot(Rd, Ro);\n    float c = dot(Ro, Ro) - s.radius*s.radius;\n    float d = b*b - a*c;\n    if (d < 0.0) {\n        return p;\n    }\n    float tp = (-b+sqrt(d)) / a;\n    float tm = (-b-sqrt(d)) / a;\n    vec3 pp = Ro + tp * Rd;\n    vec3 pm = Ro + tm * Rd;\n    \n    if (tm > 0.0) {\n        p.id = s.id;\n        p.dist = tm;\n    }\n    else if (tp > 0.0) {\n        p.id = s.id;\n        p.dist = tp;\n    }\n    return p;\n}\n\nIntersection toCylinder(Cylinder s, Ray ray) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    if (dot(Rz, ray.rd) == 0.0) {\n        return p;\n    }\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = transpose(Rmat);\n    vec3 Ro = Rinv * (ray.ro - s.p1);\n    vec3 Rd = Rinv * ray.rd;\n    float a = Rd[0]*Rd[0] + Rd[1]*Rd[1];\n    float b = Ro[0]*Rd[0] + Ro[1]*Rd[1];\n    float c = Ro[0]*Ro[0] + Ro[1]*Ro[1] - s.radius*s.radius;\n    float d = b*b - a*c;\n    if (d < 0.0) {\n        return p;\n    }\n    float tp = (-b+sqrt(d)) / a;\n    float tm = (-b-sqrt(d)) / a;\n    vec3 pp = Ro + tp * Rd;\n    vec3 pm = Ro + tm * Rd;\n    float height = length(s.p2 - s.p1);\n\n    if (tm > 0.0) {\n        if (pm[2] >= 0.0 && pm[2] <= height) {\n            p.id = s.id;\n            p.dist = tm;\n        }\n        else {\n            if (pp[2] >= 0.0 && pp[2] <= height) {\n                p.id = s.id;\n                p.dist = tp;\n            }\n            else {}\n        }\n    }\n    else {\n        if (tp > 0.0) {\n            if (pp[2] >= 0.0 && pp[2] <= height) {\n                p.id = s.id;\n                p.dist = tp;\n            }\n            else {}\n        }\n        else {}\n    }\n    return p;\n}\n\nIntersection toCone(Cone s, Ray ray) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    vec3 p0 = s.radius1/(s.radius1 - s.radius2)*(s.p2 - s.p1);\n    float ang = (s.radius1 - s.radius2) / distance(s.p2, s.p1);\n    Intersection p;\n    p.id = 0;\n    p.dist = -1.0;\n    if (dot(Rz, ray.rd) == 0.0) {\n        return p;\n    }\n    mat3 Rmat = mat3(Rx, Ry, Rz);\n    mat3 Rinv = transpose(Rmat);\n    vec3 Ro = Rinv * (ray.ro - p0);\n    vec3 Rd = Rinv * ray.rd;\n    float ang2 = ang*ang;\n    float a = Rd[0]*Rd[0] + Rd[1]*Rd[1] - ang2*Rd[2]*Rd[2];\n    float b = Ro[0]*Rd[0] + Ro[1]*Rd[1] - ang2*Ro[2]*Rd[2];\n    float c = Ro[0]*Ro[0] + Ro[1]*Ro[1] - ang2*Ro[2]*Ro[2];\n    float d = b*b - a*c;\n    if (d < 0.0) {\n        return p;\n    }\n    float tp = (-b+sqrt(d)) / a;\n    float tm = (-b-sqrt(d)) / a;\n    vec3 pp = Ro + tp * Rd;\n    vec3 pm = Ro + tm * Rd;\n    float height = length(s.p2 - s.p1);\n\n    if (tm > 0.0) {\n        if (pm[2] <= 0.0 && pm[2] >= -height) {\n            p.id = s.id;\n            p.dist = tm;\n        }\n        else {\n            if (pp[2] <= 0.0 && pp[2] >= -height) {\n                p.id = s.id;\n                p.dist = tp;\n            }\n            else {}\n        }\n    }\n    else {\n        if (tp > 0.0) {\n            if (pp[2] <= 0.0 && pp[2] >= -height) {\n                p.id = s.id;\n                p.dist = tp;\n            }\n            else {}\n        }\n        else {}\n    }\n    return p;\n}\n\nRay fromDs(vec3 ro, vec3 x, vec3 y, vec3 z) {\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(x, y, z); \n    vec3 rd = Rmat * rdLocal;\n    Ray ray;\n    ray.ro = ro;\n    ray.rd = rd;\n    return ray;\n}\n\nRay fromDisk(Disk s) {\n    float r = s.radius*sqrt(floatMRG32k3a());\n    float theta = 2.0*PI*floatMRG32k3a();\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    Ray ray;\n    ray.ro = s.p1 + r*cos(theta)*Rx + r*sin(theta)*Ry;\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(Rx, Ry, Rz); \n    ray.rd = Rmat * rdLocal;\n    return ray;\n}\n\nRay fromRect(Rectangle s) {\n    vec3 xvec = s.p2 - s.p1;\n    vec3 yvec = s.p3 - s.p1;\n    vec3 Rx = normalize(xvec);\n    vec3 Ry = normalize(yvec);\n    vec3 Rz = cross(Rx, Ry);\n    Ray ray;\n    ray.ro = s.p1 + floatMRG32k3a()*xvec + floatMRG32k3a()*yvec;\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(Rx, Ry, Rz); \n    ray.rd = Rmat * rdLocal;\n    return ray;\n}\n\nRay fromCylinder(Cylinder s) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    float height = length(s.p2 - s.p1);\n    Ray ray;\n    float theta = 2.0*PI*floatMRG32k3a();\n    ray.ro = s.p1 + height*floatMRG32k3a()*Rz + s.radius*cos(theta)*Rx + s.radius*sin(theta)*Ry;\n    vec3 rotRz = cos(theta)*Rx + sin(theta)*Ry;\n    vec3 rotRx = cos(theta+PI/2.0)*Rx + sin(theta+PI/2.0)*Ry;\n    vec3 rotRy = Rz;\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz); \n    ray.rd = -Rmat * rdLocal;\n    return ray;\n}\n\nRay fromSphere(Sphere s) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    float theta = acos(1.0-2.0*floatMRG32k3a());\n    float thetav = theta + PI/2.0;\n    float omega = 2.0*PI*floatMRG32k3a();\n    Ray ray;\n    vec3 rotRz = vec3(cos(theta)*Rz + sin(theta)*cos(omega)*Rx + sin(theta)*sin(omega)*Ry);\n    vec3 rotRx = vec3(cos(thetav)*Rz + sin(thetav)*cos(omega)*Rx + sin(thetav)*sin(omega)*Ry);\n    vec3 rotRy = cross(rotRz, rotRx);\n    ray.ro = s.p1 + s.radius*rotRz;\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz);\n    ray.rd = Rmat * rdLocal;\n    return ray;\n}\n\nRay fromCone(Cone s) {\n    vec3 Rx = normalize(s.p3 - s.p1);\n    vec3 Rz = normalize(s.p2 - s.p1);\n    vec3 Ry = cross(Rz, Rx);\n    float height = length(s.p2 - s.p1);\n    float tan_theta = (s.radius1 - s.radius2) / height;\n    float theta = atan(tan_theta);\n    float omega = 2.0*PI*floatMRG32k3a();\n    float r1_tan = s.radius1/tan_theta;\n    float q = floatMRG32k3a();\n    float h = r1_tan - sqrt(r1_tan*r1_tan - 2.0*q*height*r1_tan + q*height*height);\n    float r = s.radius1 - (s.radius1 - s.radius2) * h / height;\n    Ray ray;\n    ray.ro = s.p1 + h*Rz + r*cos(omega)*Rx + r*sin(omega)*Ry;\n    vec3 rotRz = cos(theta)*(cos(omega)*Rx + sin(omega)*Ry) + sin(theta)*Rz;\n    vec3 rotRx = cos(omega+PI/2.0)*Rx + sin(omega+PI/2.0)*Ry;\n    vec3 rotRy = -sin(theta)*(cos(omega)*Rx + sin(omega)*Ry) + cos(theta)*Rz;\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\n    float phi = 2.0*PI*floatMRG32k3a();\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz);\n    ray.rd = Rmat * rdLocal;\n    return ray;\n}\n\nint dsToDisk(void) {\n    vec3 x = vec3(cos(uTheta),0.0,-sin(uTheta));\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(sin(uTheta),0.0,cos(uTheta));\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Disk disk;\n    disk.p1 = vec3(0.0, 0.0, uH);\n    disk.p2 = vec3(0.0, 0.0, uH+1.0);\n    disk.p3 = vec3(1.0, 0.0, uH);\n    disk.id = 1;\n    disk.radius = uR;\n\n    Intersection p = toDisk(disk, ray);\n    return p.id;\n}\n\nint dsToDiskOffsetParallel(void) {\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    Ray ray = fromDs(vec3(uA, 0.0, 0.0), x, y, z);\n\n    Disk disk;\n    disk.p1 = vec3(0.0, 0.0, uH);\n    disk.p2 = vec3(0.0, 0.0, uH+1.0);\n    disk.p3 = vec3(1.0, 0.0, uH);\n    disk.id = 1;\n    disk.radius = uR;\n\n    Intersection p = toDisk(disk, ray);\n    return p.id;\n}\n\nint dsToRectParallel(void) {\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Rectangle rect;\n    rect.p1 = vec3(0.0, 0.0, uC);\n    rect.p2 = vec3(uA, 0.0, uC);\n    rect.p3 = vec3(0.0, uB, uC);\n    rect.id = 1;\n\n    Intersection p = toRect(rect, ray);\n    return p.id;\n}\n\nint dsToRectVertical(void) {\n    vec3 x = vec3(0.0, 1.0, 0.0);\n    vec3 y = vec3(0.0, 0.0, 1.0);\n    vec3 z = vec3(1.0, 0.0, 0.0);\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Rectangle rect;\n    rect.p1 = vec3(0.0, 0.0, uC);\n    rect.p2 = vec3(uA, 0.0, uC);\n    rect.p3 = vec3(0.0, uB, uC);\n    rect.id = 1;\n\n    Intersection p = toRect(rect, ray);\n    return p.id;\n}\n\nint dsToSphere(void) {\n    vec3 x = vec3(cos(uTheta),0.0,-sin(uTheta));\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(sin(uTheta),0.0,cos(uTheta));\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Sphere sphere;\n    sphere.p1 = vec3(0.0, 0.0, uH);\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\n    sphere.p3 = vec3(1.0, 0.0, uH);\n    sphere.id = 1;\n    sphere.radius = uR;\n\n    Intersection p = toSphere(sphere, ray);\n    return p.id;\n}\n\nint dsToCylinder(void) {\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Cylinder cylinder;\n    cylinder.p1 = vec3(0.0, 0.0, uH);\n    cylinder.p2 = vec3(uL, 0.0, uH);\n    cylinder.p3 = vec3(0.0, 0.0, uH+1.0);\n    cylinder.id = 1;\n    cylinder.radius = uR;\n\n    Intersection p = toCylinder(cylinder, ray);\n    return p.id;\n}\n\nint dsToTriangle(void) {\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\n\n    Triangle tri;\n    tri.p1 = vec3(0.0, 0.0, uH);\n    tri.p2 = vec3(uL, 0.0, uH);\n    tri.p3 = vec3(uL, uL*tan(uTheta), uH);\n    tri.id = 1;\n\n    Intersection p = toTriangle(tri, ray);\n    return p.id;\n}\n\nint diskToDisk(void) {\n    Disk fd;\n    fd.p1 = vec3(0.0, 0.0, 0.0);\n    fd.p2 = vec3(0.0, 0.0, 1.0);\n    fd.p3 = vec3(1.0, 0.0, 0.0);\n    fd.id = 1;\n    fd.radius = uR1;\n    Ray ray = fromDisk(fd);\n\n    Disk td;\n    td.p1 = vec3(0.0, 0.0, uH);\n    td.p2 = vec3(0.0, 0.0, uH+1.0);\n    td.p3 = vec3(1.0, 0.0, uH);\n    td.id = 2;\n    td.radius = uR2;\n\n    Intersection p = toDisk(td, ray);\n    return p.id;\n}\n\nint rectToRectParallel(void) {\n    Rectangle frect;\n    frect.p1 = vec3(0.0, 0.0, 0.0);\n    frect.p2 = vec3(uA, 0.0, 0.0);\n    frect.p3 = vec3(0.0, uB, 0.0);\n    frect.id = 1;\n    Ray ray = fromRect(frect);\n\n    Rectangle trect;\n    trect.p1 = vec3(0.0, 0.0, uC);\n    trect.p2 = vec3(uA, 0.0, uC);\n    trect.p3 = vec3(0.0, uB, uC);\n    trect.id = 2;\n\n    Intersection p = toRect(trect, ray);\n    return p.id;\n}\n\nint rectToRectVertical(void) {\n    Rectangle frect;\n    frect.p1 = vec3(0.0, 0.0, 0.0);\n    frect.p2 = vec3(uW, 0.0, 0.0);\n    frect.p3 = vec3(0.0, uL, 0.0);\n    frect.id = 1;\n    Ray ray = fromRect(frect);\n\n    Rectangle trect;\n    trect.p1 = vec3(0.0, 0.0, 0.0);\n    trect.p2 = vec3(0.0, uL, 0.0);\n    trect.p3 = vec3(0.0, 0.0, uH);\n    trect.id = 2;\n\n    Intersection p = toRect(trect, ray);\n    return p.id;\n}\n\nint sphereToRect(void) {\n    Sphere sphere;\n    sphere.p1 = vec3(0.0, 0.0, uH);\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\n    sphere.p3 = vec3(1.0, 0.0, uH);\n    sphere.id = 1;\n    sphere.radius = 1.0;\n    Ray ray = fromSphere(sphere);\n\n    Rectangle rect;\n    rect.p1 = vec3(0.0, 0.0, 0.0);\n    rect.p2 = vec3(uL1, 0.0, 0.0);\n    rect.p3 = vec3(0.0, uL2, 0.0);\n    rect.id = 2;\n\n    Intersection p = toRect(rect, ray);\n    return p.id;\n}\n\nint sphereToDisk(void) {\n    Sphere sphere;\n    sphere.p1 = vec3(0.0, 0.0, uH);\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\n    sphere.p3 = vec3(1.0, 0.0, uH);\n    sphere.id = 1;\n    sphere.radius = 1.0;\n    Ray ray = fromSphere(sphere);\n\n    Disk disk;\n    disk.p1 = vec3(0.0, 0.0, 0.0);\n    disk.p2 = vec3(0.0, 0.0, 1.0);\n    disk.p3 = vec3(1.0, 0.0, 0.0);\n    disk.id = 2;\n    disk.radius = uR;\n\n    Intersection p = toDisk(disk, ray);\n    return p.id;\n}\n\nint sphereToCone(void) {\n    Sphere sphere;\n    sphere.p1 = vec3(0.0, 0.0, uR2/tan(uTheta)+uH+uR1);\n    sphere.p2 = vec3(0.0, 0.0, uR2/tan(uTheta)+uH+uR1+1.0);\n    sphere.p3 = vec3(1.0, 0.0, uR2/tan(uTheta)+uH+uR1);\n    sphere.id = 1;\n    sphere.radius = uR1;\n    Ray ray = fromSphere(sphere);\n\n    Cone cone;\n    cone.p1 = vec3(0.0, 0.0, 0.0);\n    cone.p2 = vec3(0.0, 0.0, uR2/tan(uTheta));\n    cone.p3 = vec3(1.0, 0.0, 0.0);\n    cone.id = 2;\n    cone.radius1 = uR2;\n    cone.radius2 = 0.0;\n\n    Intersection p = toCone(cone, ray);\n    return p.id;\n}\n\nint cylinderToCylinder(void) {\n    Cylinder fcylinder;\n    fcylinder.p1 = vec3(0.0, 0.0, 0.0);\n    fcylinder.p2 = vec3(0.0, 0.0, uH);\n    fcylinder.p3 = vec3(1.0, 0.0, 0.0);\n    fcylinder.id = 1;\n    fcylinder.radius = uR2;\n    Ray ray = fromCylinder(fcylinder);\n\n    Cylinder tcylinder;\n    tcylinder.p1 = vec3(0.0, 0.0, 0.0);\n    tcylinder.p2 = vec3(0.0, 0.0, uH);\n    tcylinder.p3 = vec3(1.0, 0.0, 0.0);\n    tcylinder.id = 2;\n    tcylinder.radius = uR1;\n\n    Intersection p = toCylinder(tcylinder, ray);\n    return p.id;\n}\n\nint diskToCylinder(void) {\n    Disk fd;\n    fd.p1 = vec3(0.0, 0.0, 0.0);\n    fd.p2 = vec3(0.0, 0.0, 1.0);\n    fd.p3 = vec3(1.0, 0.0, 0.0);\n    fd.id = 1;\n    fd.radius = uR;\n    Ray ray = fromDisk(fd);\n\n    Cylinder tcylinder;\n    tcylinder.p1 = vec3(0.0, 0.0, 0.0);\n    tcylinder.p2 = vec3(0.0, 0.0, uH);\n    tcylinder.p3 = vec3(1.0, 0.0, 0.0);\n    tcylinder.id = 2;\n    tcylinder.radius = uR;\n\n    Intersection p = toCylinder(tcylinder, ray);\n    return p.id;\n}\n\nint coneToDisk(void) {\n    Cone cone;\n    cone.p1 = vec3(0.0, 0.0, 0.0);\n    cone.p2 = vec3(0.0, 0.0, uH);\n    cone.p3 = vec3(1.0, 0.0, 0.0);\n    cone.id = 1;\n    cone.radius1 = uR;\n    cone.radius2 = 0.0;\n    Ray ray = fromCone(cone);\n    ray.rd = -1.0 * ray.rd;\n\n    Disk disk;\n    disk.p1 = vec3(0.0, 0.0, 0.0);\n    disk.p2 = vec3(0.0, 0.0, 1.0);\n    disk.p3 = vec3(1.0, 0.0, 0.0);\n    disk.id = 2;\n    disk.radius = uR;\n\n    Intersection p = toDisk(disk, ray);\n    return p.id;\n}\n\nvoid main(void) {\n    uint skip = uint(iSeed) * 100u;\n    skipMRG32k3a(skip);\n    int id;\n\n    switch (uCase) {\n        case 0:\n            id = dsToDisk();\n            break;\n        case 1:\n            id = dsToDiskOffsetParallel();\n            break;\n        // case 2:\n        //     id = dsToDiskOffsetVertical();\n        //     break;\n        case 3:\n            id = dsToRectParallel();\n            break;\n        case 4:\n            id = dsToRectVertical();\n            break;\n        case 5:\n            id = dsToSphere();\n            break;\n        case 6:\n            id = dsToCylinder();\n            break;\n        case 7:\n            id = dsToTriangle();\n            break;\n        case 10:\n            id = diskToDisk();\n            break;\n        case 11:\n            id = diskToCylinder();\n            break;\n        case 20:\n            id = rectToRectParallel();\n            break;\n        case 21:\n            id = rectToRectVertical();\n            break;\n        case 30:\n            id = sphereToRect();\n            break;\n        case 31:\n            id = sphereToDisk();\n            break;\n        // case 32:\n        //     id = sphereToCylinder();\n        //     break;\n        case 33:\n            id = sphereToCone();\n            break;\n        case 40:\n            id = cylinderToCylinder();\n            break;\n        case 50:\n            id = coneToDisk();\n            break;\n        // case 100:\n        //     id = triToTriArbitrary();\n        //     break;\n        // case 101:\n        //     id = rectTorectArbitrary();\n        //     break;\n        default:\n            id = 0;\n    }\n    \n    oCalc = float(id);\n    // oCalc = uR;\n}`;\n\n\n//# sourceURL=webpack://viewfactor/./src/vertex-shader.glsl.ts?");

/***/ }),

/***/ "./src/worker.ts":
/*!***********************!*\
  !*** ./src/worker.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nlet gl;\nlet program;\nlet tfBuffer;\nlet vao;\nlet tf;\nlet seed;\nonmessage = (evt) => {\n    let vf = 0.0;\n    switch (evt.data.type) {\n        case 'init':\n            init(evt);\n            postMessage({ 'type': 'init' });\n            break;\n        case 'ds-disk':\n            vf = dsDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-disk' });\n            break;\n        case 'ds-disk-parallel':\n            vf = dsDiskParallel(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-disk-parallel' });\n            break;\n        case 'ds-rect-p':\n            vf = dsRectP(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-rect-p' });\n            break;\n        case 'ds-rect-v':\n            vf = dsRectV(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-rect-v' });\n            break;\n        case 'ds-sphere':\n            vf = dsSphere(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-sphere' });\n            break;\n        case 'ds-cylinder':\n            vf = dsCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-cylinder' });\n            break;\n        case 'ds-triangle':\n            vf = dsTriangle(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-triangle' });\n            break;\n        case 'disk-disk':\n            vf = diskDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'disk-disk' });\n            break;\n        case 'rect-rect-p':\n            vf = rectRectP(evt);\n            postMessage({ 'vf': vf, 'type': 'rect-rect-p' });\n            break;\n        case 'rect-rect-v':\n            vf = rectRectV(evt);\n            postMessage({ 'vf': vf, 'type': 'rect-rect-v' });\n            break;\n        case 'sphere-rect':\n            vf = sphereRect(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-rect' });\n            break;\n        case 'sphere-disk':\n            vf = sphereDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-disk' });\n            break;\n        case 'sphere-cone':\n            vf = sphereCone(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-cone' });\n            break;\n        case 'cylinder-cylinder':\n            vf = cylinderCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'cylinder-cylinder' });\n            break;\n        case 'disk-cylinder':\n            vf = diskCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'disk-cylinder' });\n            break;\n        case 'cone-disk':\n            vf = coneDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'cone-disk' });\n            break;\n        default:\n            throw new Error('Unknown message type');\n    }\n};\n/**\n * Counts the number of occurrences of each element in a Float32Array\n * @param {Float32Array} arr - The array to count the occurrences of each element\n * @returns {number[]} An array containing the count of each element\n */\nfunction arrayCount(arr) {\n    let count = [];\n    for (let i = 0; i < arr.length; i++) {\n        let elm = Math.floor(arr[i]);\n        // if count[elm] is falsey, set 0 + 1, otherwise count[elm] + 1\n        count[elm] = (count[elm] || 0) + 1;\n    }\n    return count;\n}\nfunction draw() {\n    if (gl === null) {\n        throw new Error('Could not get WebGL2 context');\n    }\n    // Activate the program and bind the VAO\n    gl.useProgram(program);\n    gl.bindVertexArray(vao);\n    // Disable the rasterizer and bind the Transform Feedback\n    gl.enable(gl.RASTERIZER_DISCARD);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n    // Start the Transform Feedback and execute the draw call\n    gl.beginTransformFeedback(gl.POINTS);\n    gl.drawArrays(gl.POINTS, 0, seed.length);\n    gl.endTransformFeedback();\n    // Unbind the Transform Feedback and enable the rasterizer\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    gl.disable(gl.RASTERIZER_DISCARD);\n    // Unbind the VAO and deactivate the program\n    gl.bindVertexArray(null);\n    gl.useProgram(null);\n    // Create a Float32Array and get the data from the Transform Feedback buffer\n    let result = new Float32Array(seed.length);\n    gl.bindBuffer(gl.ARRAY_BUFFER, tfBuffer);\n    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, // byte offset into GPU buffer,\n    result);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return result;\n}\nfunction dsDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 0);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsDiskParallel(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 1);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsRectP(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 3);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsRectV(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 4);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsSphere(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 5);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 6);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsTriangle(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 7);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction diskDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 10);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction rectRectP(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 20);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction rectRectV(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 21);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let wLoc = gl.getUniformLocation(program, 'uW');\n    gl.uniform1f(wLoc, evt.data.w);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereRect(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 30);\n    let l1Loc = gl.getUniformLocation(program, 'uL1');\n    gl.uniform1f(l1Loc, evt.data.l1);\n    let l2Loc = gl.getUniformLocation(program, 'uL2');\n    gl.uniform1f(l2Loc, evt.data.l2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 31);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereCone(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 33);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction cylinderCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 40);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction diskCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 11);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction coneDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 50);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction init(evt) {\n    const nRays = evt.data.nRays;\n    const canvas = evt.data.canvas;\n    gl = canvas.getContext('webgl2');\n    if (gl === null) {\n        throw new Error('Could not get WebGL2 context');\n    }\n    // Call the functions in an appropriate order\n    const vertexShader = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getVertexShader)(gl);\n    const fragmentShader = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getFragmentShader)(gl);\n    if (vertexShader === null || fragmentShader === null) {\n        throw new Error('Could not create shaders');\n    }\n    // Create a program\n    program = gl.createProgram();\n    if (program === null) {\n        throw new Error('Could not create program');\n    }\n    // Attach the shaders to this program\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.transformFeedbackVaryings(program, ['oCalc'], gl.SEPARATE_ATTRIBS);\n    gl.linkProgram(program);\n    // Check if the program linked successfully\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Could not initialize shaders');\n    }\n    // get the locations of the attributes in the related program\n    let iSeedLoc = gl.getAttribLocation(program, 'iSeed');\n    // create a vertex array object (vao)\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    // create the seed array [0, 1, 2, ..., nRays-1]\n    seed = Array.from({ length: nRays }, (_, i) => i);\n    // make a buffer for the seed in GPU memory\n    const seedBuf = gl.createBuffer();\n    // set the gl.ARRAY_BUFFER (buffer containing vertex attributes) to seedBuf \n    gl.bindBuffer(gl.ARRAY_BUFFER, seedBuf);\n    // copy the data from the seed array into the buffer\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(seed), gl.STATIC_DRAW);\n    // enable the attribute at location iSeedLoc \n    gl.enableVertexAttribArray(iSeedLoc);\n    // set the layout of the attribute at location iSeedLoc\n    gl.vertexAttribPointer(iSeedLoc, 1, // size (num components)\n    gl.FLOAT, // type of data in buffer\n    false, // normalize\n    0, // stride (0 = auto)\n    0);\n    gl.bindVertexArray(null);\n    // transform feedback object\n    tf = gl.createTransformFeedback();\n    // make buffers for output\n    tfBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, tfBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nRays), gl.DYNAMIC_COPY);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    // bind the buffers to the transform feedback\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, tfBuffer);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n}\n\n\n//# sourceURL=webpack://viewfactor/./src/worker.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worker.ts");
/******/ 	
/******/ })()
;