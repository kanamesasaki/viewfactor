/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/fragment-shader.glsl.ts":
/*!*************************************!*\
  !*** ./src/fragment-shader.glsl.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragment: () => (/* binding */ fragment)\n/* harmony export */ });\nconst fragment = `#version 300 es\r\nprecision highp float;\r\n\r\nvoid main() {}`;\n\n\n//# sourceURL=webpack://viewfactor/./src/fragment-shader.glsl.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFragmentShader: () => (/* binding */ getFragmentShader),\n/* harmony export */   getVertexShader: () => (/* binding */ getVertexShader)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.glsl */ \"./src/vertex-shader.glsl.ts\");\n/* harmony import */ var _fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fragment-shader.glsl */ \"./src/fragment-shader.glsl.ts\");\n\n\n// Extract the content's of a shader script from the JavaScript file \n// Return the compiled shader\nfunction getVertexShader(gl) {\n    let shader;\n    shader = gl.createShader(gl.VERTEX_SHADER);\n    if (shader === null) {\n        throw new Error('Could not create vertex shader');\n    }\n    gl.shaderSource(shader, _vertex_shader_glsl__WEBPACK_IMPORTED_MODULE_0__.vertex);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(shader));\n        return null;\n    }\n    return shader;\n}\n// Extract the content's of a shader script from the JavaScript file \n// Return the compiled shader\nfunction getFragmentShader(gl) {\n    let shader;\n    shader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (shader === null) {\n        throw new Error('Could not create fragment shader');\n    }\n    gl.shaderSource(shader, _fragment_shader_glsl__WEBPACK_IMPORTED_MODULE_1__.fragment);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(shader));\n        return null;\n    }\n    return shader;\n}\n\n\n//# sourceURL=webpack://viewfactor/./src/utils.ts?");

/***/ }),

/***/ "./src/vertex-shader.glsl.ts":
/*!***********************************!*\
  !*** ./src/vertex-shader.glsl.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertex: () => (/* binding */ vertex)\n/* harmony export */ });\nconst vertex = `#version 300 es\r\nprecision highp float;\r\n\r\nin float iSeed;\r\nout float oCalc;\r\n\r\n// Calculation case\r\nuniform int uCase;\r\n// 0: dsToDisk\r\n// 1: dsToDiskOffsetParallel\r\n// 2: dsToDiskOffsetVertical\r\n// 3: dsToRectParallel\r\n// 4: dsToRectVertical\r\n// 5: dsToSphere\r\n// 6: dsToCylinder\r\n// 7: dsToTriangle\r\n\r\n// 10: diskToDisk\r\n// 11: diskToCylinder\r\n// 20: rectToRectParallel\r\n// 21: rectToRectVertical\r\n// 30: sphereToRect\r\n// 31: sphereToDisk\r\n// 32: sphereToCylinder\r\n// 33: spehreToCone\r\n// 40: cylinderToCylinder\r\n// 50: coneToDisk\r\n\r\n// 100: triToTriArbitrary\r\n// 101: rectTorectArbitrary\r\n\r\nuniform float uR;\r\nuniform float uH;\r\nuniform float uTheta;\r\nuniform float uA;\r\nuniform float uB;\r\nuniform float uC;\r\nuniform float uR1;\r\nuniform float uR2;\r\nuniform float uL;\r\nuniform float uL1;\r\nuniform float uL2;\r\nuniform float uW;\r\nuniform float uTest;\r\n\r\nconst float PI = 3.141592653589793238462643383;\r\n\r\n// MRG32k3a parameters\r\nuint[3] x1 = uint[3](0u, 0u, 1234567u);\r\nuint[3] x2 = uint[3](0u, 0u, 1234567u);\r\nconst uint[9] a1 = uint[9](0u, 1u, 0u, 0u, 0u, 1u, 4294156359u, 1403580u, 0u);\r\nconst uint[9] a2 = uint[9](0u, 1u, 0u, 0u, 0u, 1u, 4293573854u, 0u, 527612u);\r\nconst uint m1 = 4294967087u;\r\nconst uint m2 = 4294944443u;\r\nconst uint a11 = 1403580u;\r\nconst uint a10 = 810728u;\r\nconst uint a22 = 527612u;\r\nconst uint a20 = 1370589u;\r\n\r\nuint addModM(uint a, uint b, uint m) {\r\n    uint amodm = a % m;\r\n    uint bmodm = b % m;\r\n    uint blim = m - amodm;\r\n    if (bmodm <= blim) {\r\n        return amodm + bmodm; \r\n    }\r\n    else {\r\n        return amodm - (m - bmodm);\r\n    }\r\n}\r\n\r\nuint diffModM(uint a, uint b, uint m) {\r\n    uint amodm = a % m;\r\n    uint bmodm = b % m;\r\n    if (amodm >= bmodm) {\r\n        return amodm - bmodm;\r\n    }\r\n    else {\r\n        return amodm + (m - bmodm);\r\n    }\r\n}\r\n\r\nuint multModM(uint a, uint b, uint m) {\r\n    uint amodm = a % m;\r\n    uint bmodm = b % m;\r\n    uint res = 0u;\r\n    while (bmodm > 0u) {\r\n        if ((bmodm&0x1u) == 0x1u) {\r\n            res = addModM(res, amodm, m);\r\n        }\r\n        bmodm = bmodm >> 1;\r\n        amodm = addModM(amodm, amodm, m);\r\n    }\r\n    return res;\r\n}\r\n\r\n// calculate c = a*b mod m\r\nvoid matMultModM(uint[9] a, uint[9] b, uint m, out uint[9] c) {\r\n    c[0] = addModM(addModM(multModM(a[0],b[0],m), multModM(a[1],b[3],m), m), multModM(a[2],b[6],m), m);\r\n    c[1] = addModM(addModM(multModM(a[0],b[1],m), multModM(a[1],b[4],m), m), multModM(a[2],b[7],m), m);\r\n    c[2] = addModM(addModM(multModM(a[0],b[2],m), multModM(a[1],b[5],m), m), multModM(a[2],b[8],m), m);\r\n    c[3] = addModM(addModM(multModM(a[3],b[0],m), multModM(a[4],b[3],m), m), multModM(a[5],b[6],m), m);\r\n    c[4] = addModM(addModM(multModM(a[3],b[1],m), multModM(a[4],b[4],m), m), multModM(a[5],b[7],m), m);\r\n    c[5] = addModM(addModM(multModM(a[3],b[2],m), multModM(a[4],b[5],m), m), multModM(a[5],b[8],m), m);\r\n    c[6] = addModM(addModM(multModM(a[6],b[0],m), multModM(a[7],b[3],m), m), multModM(a[8],b[6],m), m);\r\n    c[7] = addModM(addModM(multModM(a[6],b[1],m), multModM(a[7],b[4],m), m), multModM(a[8],b[7],m), m);\r\n    c[8] = addModM(addModM(multModM(a[6],b[2],m), multModM(a[7],b[5],m), m), multModM(a[8],b[8],m), m);\r\n}\r\n\r\n// calculate w = a*v mod m\r\nvoid matVecMultModM(uint[9] a, uint[3] v, uint m, out uint[3] w) {\r\n    w[0] = addModM(addModM(multModM(a[0],v[0],m), multModM(a[1],v[1],m), m), multModM(a[2],v[2],m), m);\r\n    w[1] = addModM(addModM(multModM(a[3],v[0],m), multModM(a[4],v[1],m), m), multModM(a[5],v[2],m), m);\r\n    w[2] = addModM(addModM(multModM(a[6],v[0],m), multModM(a[7],v[1],m), m), multModM(a[8],v[2],m), m);\r\n}\r\n\r\n// calculate c = a+b mod m\r\nvoid matVecMultModM(uint[3] a, uint[3] b, uint m, out uint[9] c) {\r\n    c[0] = addModM(a[0], b[0], m);\r\n    c[1] = addModM(a[1], b[1], m);\r\n    c[2] = addModM(a[2], b[2], m);\r\n}\r\n\r\n// calculate b = a**n mod m\r\nvoid matPowModM(uint[9] a, uint n, uint m, out uint[9] b) {\r\n    uint[9] apow = a;\r\n    b = uint[9](1u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 1u);\r\n    while (n > 0u) {\r\n        if ((n&0x1u) == 0x1u) {\r\n            matMultModM(apow, b, m, b);\r\n        }\r\n        n = n >> 1;\r\n        matMultModM(apow, apow, m, apow);\r\n    }\r\n}\r\n\r\nuint stepMRG32k3a(void) {\r\n    uint x1i = diffModM(multModM(x1[1], a11, m1), multModM(x1[0], a10, m1), m1);\r\n    uint x2i = diffModM(multModM(x2[2], a22, m2), multModM(x2[0], a20, m2), m2);\r\n    x1[0] = x1[1];\r\n    x1[1] = x1[2];\r\n    x1[2] = x1i;\r\n    x2[0] = x2[1];\r\n    x2[1] = x2[2];\r\n    x2[2] = x2i;\r\n    return diffModM(x1i, x2i, m1);\r\n}\r\n\r\nfloat floatMRG32k3a(void) {\r\n    return float(stepMRG32k3a())*(1.0/4294967086.0);\r\n}\r\n\r\nuint skipMRG32k3a(uint n) {\r\n    uint[9] a1pow;\r\n    uint[9] a2pow;\r\n    matPowModM(a1, n, m1, a1pow);\r\n    matPowModM(a2, n, m2, a2pow);\r\n    matVecMultModM(a1pow, x1, m1, x1);\r\n    matVecMultModM(a2pow, x2, m2, x2);\r\n    return diffModM(x1[0], x2[0], m1);\r\n}\r\n\r\nuniform struct Ray {\r\n    vec3 ro;\r\n    vec3 rd;\r\n};\r\n\r\nuniform struct Intersection {\r\n    float dist;\r\n    int id;\r\n};\r\n\r\nuniform struct Disk {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n    float radius;\r\n};\r\n\r\nuniform struct Rectangle {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n};\r\n\r\nuniform struct Triangle {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n};\r\n\r\nuniform struct Sphere {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n    float radius;\r\n};\r\n\r\nuniform struct Cylinder {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n    float radius;\r\n};\r\n\r\nuniform struct Cone {\r\n    int id;\r\n    vec3 p1;\r\n    vec3 p2;\r\n    vec3 p3;\r\n    float radius1;\r\n    float radius2;\r\n};\r\n\r\nIntersection toDisk(Disk s, Ray ray) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    if (dot(Rz, ray.rd) == 0.0) {\r\n        return p;\r\n    }\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = transpose(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - s.p1);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    float t = -Ro[2]/Rd[2];\r\n    if (t <= 0.0) {\r\n        return p;\r\n    }\r\n    vec3 pLocal = Ro + Rd * t;\r\n    float dist = pLocal[0]*pLocal[0] + pLocal[1]*pLocal[1];\r\n    if (dist < s.radius*s.radius) {\r\n        p.id = s.id;\r\n        p.dist = t;\r\n    }\r\n    return p;\r\n}\r\n\r\nIntersection toRect(Rectangle s, Ray ray) {\r\n    vec3 Ry = normalize(s.p3 - s.p1);\r\n    vec3 Rx = normalize(s.p2 - s.p1);\r\n    vec3 Rz = cross(Rx, Ry);\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    if (dot(Rz, ray.rd) == 0.0) {\r\n        return p;\r\n    }\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = transpose(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - s.p1);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    float t = -Ro[2]/Rd[2];\r\n    if (t <= 0.0) {\r\n        return p;\r\n    }\r\n    vec3 pLocal = Ro + Rd * t;\r\n    if (0.0 <= pLocal[0] && pLocal[0] <= length(s.p2 - s.p1) && 0.0 <= pLocal[1] && pLocal[1] <= length(s.p3 - s.p1)) {\r\n        p.id = s.id;\r\n        p.dist = t;\r\n    }\r\n    return p;\r\n}\r\n\r\nIntersection toTriangle(Triangle s, Ray ray) {\r\n    vec3 Ry = s.p3 - s.p1;\r\n    vec3 Rx = s.p2 - s.p1;\r\n    vec3 Rz = cross(Rx, Ry);\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    if (dot(Rz, ray.rd) == 0.0) {\r\n        return p;\r\n    }\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = inverse(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - s.p1);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    float t = -Ro[2]/Rd[2];\r\n    if (t <= 0.0) {\r\n        return p;\r\n    }\r\n    vec3 pLocal = Ro + Rd * t;\r\n    if (0.0 <= pLocal[0] && pLocal[0] <= 1.0 && 0.0 <= pLocal[1] && pLocal[1] <= 1.0 && 0.0 <= pLocal[0] + pLocal[1] && pLocal[0] + pLocal[1] <= 1.0) {\r\n        p.id = s.id;\r\n        p.dist = t;\r\n    }\r\n    return p;\r\n}\r\n\r\nIntersection toSphere(Sphere s, Ray ray) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = transpose(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - s.p1);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    float a = dot(Rd, Rd);\r\n    float b = dot(Rd, Ro);\r\n    float c = dot(Ro, Ro) - s.radius*s.radius;\r\n    float d = b*b - a*c;\r\n    if (d < 0.0) {\r\n        return p;\r\n    }\r\n    float tp = (-b+sqrt(d)) / a;\r\n    float tm = (-b-sqrt(d)) / a;\r\n    vec3 pp = Ro + tp * Rd;\r\n    vec3 pm = Ro + tm * Rd;\r\n    \r\n    if (tm > 0.0) {\r\n        p.id = s.id;\r\n        p.dist = tm;\r\n    }\r\n    else if (tp > 0.0) {\r\n        p.id = s.id;\r\n        p.dist = tp;\r\n    }\r\n    return p;\r\n}\r\n\r\nIntersection toCylinder(Cylinder s, Ray ray) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    if (dot(Rz, ray.rd) == 0.0) {\r\n        return p;\r\n    }\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = transpose(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - s.p1);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    float a = Rd[0]*Rd[0] + Rd[1]*Rd[1];\r\n    float b = Ro[0]*Rd[0] + Ro[1]*Rd[1];\r\n    float c = Ro[0]*Ro[0] + Ro[1]*Ro[1] - s.radius*s.radius;\r\n    float d = b*b - a*c;\r\n    if (d < 0.0) {\r\n        return p;\r\n    }\r\n    float tp = (-b+sqrt(d)) / a;\r\n    float tm = (-b-sqrt(d)) / a;\r\n    vec3 pp = Ro + tp * Rd;\r\n    vec3 pm = Ro + tm * Rd;\r\n    float height = length(s.p2 - s.p1);\r\n\r\n    if (tm > 0.0) {\r\n        if (pm[2] >= 0.0 && pm[2] <= height) {\r\n            p.id = s.id;\r\n            p.dist = tm;\r\n        }\r\n        else {\r\n            if (pp[2] >= 0.0 && pp[2] <= height) {\r\n                p.id = s.id;\r\n                p.dist = tp;\r\n            }\r\n            else {}\r\n        }\r\n    }\r\n    else {\r\n        if (tp > 0.0) {\r\n            if (pp[2] >= 0.0 && pp[2] <= height) {\r\n                p.id = s.id;\r\n                p.dist = tp;\r\n            }\r\n            else {}\r\n        }\r\n        else {}\r\n    }\r\n    return p;\r\n}\r\n\r\nIntersection toCone(Cone s, Ray ray) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    vec3 p0 = s.radius1/(s.radius1 - s.radius2)*(s.p2 - s.p1);\r\n    float ang = (s.radius1 - s.radius2) / distance(s.p2, s.p1);\r\n    Intersection p;\r\n    p.id = 0;\r\n    p.dist = -1.0;\r\n    if (dot(Rz, ray.rd) == 0.0) {\r\n        return p;\r\n    }\r\n    mat3 Rmat = mat3(Rx, Ry, Rz);\r\n    mat3 Rinv = transpose(Rmat);\r\n    vec3 Ro = Rinv * (ray.ro - p0);\r\n    vec3 Rd = Rinv * ray.rd;\r\n    float ang2 = ang*ang;\r\n    float a = Rd[0]*Rd[0] + Rd[1]*Rd[1] - ang2*Rd[2]*Rd[2];\r\n    float b = Ro[0]*Rd[0] + Ro[1]*Rd[1] - ang2*Ro[2]*Rd[2];\r\n    float c = Ro[0]*Ro[0] + Ro[1]*Ro[1] - ang2*Ro[2]*Ro[2];\r\n    float d = b*b - a*c;\r\n    if (d < 0.0) {\r\n        return p;\r\n    }\r\n    float tp = (-b+sqrt(d)) / a;\r\n    float tm = (-b-sqrt(d)) / a;\r\n    vec3 pp = Ro + tp * Rd;\r\n    vec3 pm = Ro + tm * Rd;\r\n    float height = length(s.p2 - s.p1);\r\n\r\n    if (tm > 0.0) {\r\n        if (pm[2] <= 0.0 && pm[2] >= -height) {\r\n            p.id = s.id;\r\n            p.dist = tm;\r\n        }\r\n        else {\r\n            if (pp[2] <= 0.0 && pp[2] >= -height) {\r\n                p.id = s.id;\r\n                p.dist = tp;\r\n            }\r\n            else {}\r\n        }\r\n    }\r\n    else {\r\n        if (tp > 0.0) {\r\n            if (pp[2] <= 0.0 && pp[2] >= -height) {\r\n                p.id = s.id;\r\n                p.dist = tp;\r\n            }\r\n            else {}\r\n        }\r\n        else {}\r\n    }\r\n    return p;\r\n}\r\n\r\nRay fromDs(vec3 ro, vec3 x, vec3 y, vec3 z) {\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(x, y, z); \r\n    vec3 rd = Rmat * rdLocal;\r\n    Ray ray;\r\n    ray.ro = ro;\r\n    ray.rd = rd;\r\n    return ray;\r\n}\r\n\r\nRay fromDisk(Disk s) {\r\n    float r = s.radius*sqrt(floatMRG32k3a());\r\n    float theta = 2.0*PI*floatMRG32k3a();\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    Ray ray;\r\n    ray.ro = s.p1 + r*cos(theta)*Rx + r*sin(theta)*Ry;\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(Rx, Ry, Rz); \r\n    ray.rd = Rmat * rdLocal;\r\n    return ray;\r\n}\r\n\r\nRay fromRect(Rectangle s) {\r\n    vec3 xvec = s.p2 - s.p1;\r\n    vec3 yvec = s.p3 - s.p1;\r\n    vec3 Rx = normalize(xvec);\r\n    vec3 Ry = normalize(yvec);\r\n    vec3 Rz = cross(Rx, Ry);\r\n    Ray ray;\r\n    ray.ro = s.p1 + floatMRG32k3a()*xvec + floatMRG32k3a()*yvec;\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(Rx, Ry, Rz); \r\n    ray.rd = Rmat * rdLocal;\r\n    return ray;\r\n}\r\n\r\nRay fromCylinder(Cylinder s) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    float height = length(s.p2 - s.p1);\r\n    Ray ray;\r\n    float theta = 2.0*PI*floatMRG32k3a();\r\n    ray.ro = s.p1 + height*floatMRG32k3a()*Rz + s.radius*cos(theta)*Rx + s.radius*sin(theta)*Ry;\r\n    vec3 rotRz = cos(theta)*Rx + sin(theta)*Ry;\r\n    vec3 rotRx = cos(theta+PI/2.0)*Rx + sin(theta+PI/2.0)*Ry;\r\n    vec3 rotRy = Rz;\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz); \r\n    ray.rd = -Rmat * rdLocal;\r\n    return ray;\r\n}\r\n\r\nRay fromSphere(Sphere s) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    float theta = acos(1.0-2.0*floatMRG32k3a());\r\n    float thetav = theta + PI/2.0;\r\n    float omega = 2.0*PI*floatMRG32k3a();\r\n    Ray ray;\r\n    vec3 rotRz = vec3(cos(theta)*Rz + sin(theta)*cos(omega)*Rx + sin(theta)*sin(omega)*Ry);\r\n    vec3 rotRx = vec3(cos(thetav)*Rz + sin(thetav)*cos(omega)*Rx + sin(thetav)*sin(omega)*Ry);\r\n    vec3 rotRy = cross(rotRz, rotRx);\r\n    ray.ro = s.p1 + s.radius*rotRz;\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz);\r\n    ray.rd = Rmat * rdLocal;\r\n    return ray;\r\n}\r\n\r\nRay fromCone(Cone s) {\r\n    vec3 Rx = normalize(s.p3 - s.p1);\r\n    vec3 Rz = normalize(s.p2 - s.p1);\r\n    vec3 Ry = cross(Rz, Rx);\r\n    float height = length(s.p2 - s.p1);\r\n    float tan_theta = (s.radius1 - s.radius2) / height;\r\n    float theta = atan(tan_theta);\r\n    float omega = 2.0*PI*floatMRG32k3a();\r\n    float r1_tan = s.radius1/tan_theta;\r\n    float q = floatMRG32k3a();\r\n    float h = r1_tan - sqrt(r1_tan*r1_tan - 2.0*q*height*r1_tan + q*height*height);\r\n    float r = s.radius1 - (s.radius1 - s.radius2) * h / height;\r\n    Ray ray;\r\n    ray.ro = s.p1 + h*Rz + r*cos(omega)*Rx + r*sin(omega)*Ry;\r\n    vec3 rotRz = cos(theta)*(cos(omega)*Rx + sin(omega)*Ry) + sin(theta)*Rz;\r\n    vec3 rotRx = cos(omega+PI/2.0)*Rx + sin(omega+PI/2.0)*Ry;\r\n    vec3 rotRy = -sin(theta)*(cos(omega)*Rx + sin(omega)*Ry) + cos(theta)*Rz;\r\n    float psi = acos(1.0-2.0*floatMRG32k3a())/2.0;\r\n    float phi = 2.0*PI*floatMRG32k3a();\r\n    vec3 rdLocal = vec3(sin(psi)*cos(phi), sin(psi)*sin(phi), cos(psi));\r\n    mat3 Rmat = mat3(rotRx, rotRy, rotRz);\r\n    ray.rd = Rmat * rdLocal;\r\n    return ray;\r\n}\r\n\r\nint dsToDisk(void) {\r\n    vec3 x = vec3(cos(uTheta),0.0,-sin(uTheta));\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(sin(uTheta),0.0,cos(uTheta));\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Disk disk;\r\n    disk.p1 = vec3(0.0, 0.0, uH);\r\n    disk.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    disk.p3 = vec3(1.0, 0.0, uH);\r\n    disk.id = 1;\r\n    disk.radius = uR;\r\n\r\n    Intersection p = toDisk(disk, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToDiskOffsetParallel(void) {\r\n    vec3 x = vec3(1.0, 0.0, 0.0);\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(0.0, 0.0, 1.0);\r\n    Ray ray = fromDs(vec3(uA, 0.0, 0.0), x, y, z);\r\n\r\n    Disk disk;\r\n    disk.p1 = vec3(0.0, 0.0, uH);\r\n    disk.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    disk.p3 = vec3(1.0, 0.0, uH);\r\n    disk.id = 1;\r\n    disk.radius = uR;\r\n\r\n    Intersection p = toDisk(disk, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToRectParallel(void) {\r\n    vec3 x = vec3(1.0, 0.0, 0.0);\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(0.0, 0.0, 1.0);\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Rectangle rect;\r\n    rect.p1 = vec3(0.0, 0.0, uC);\r\n    rect.p2 = vec3(uA, 0.0, uC);\r\n    rect.p3 = vec3(0.0, uB, uC);\r\n    rect.id = 1;\r\n\r\n    Intersection p = toRect(rect, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToRectVertical(void) {\r\n    vec3 x = vec3(0.0, 1.0, 0.0);\r\n    vec3 y = vec3(0.0, 0.0, 1.0);\r\n    vec3 z = vec3(1.0, 0.0, 0.0);\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Rectangle rect;\r\n    rect.p1 = vec3(0.0, 0.0, uC);\r\n    rect.p2 = vec3(uA, 0.0, uC);\r\n    rect.p3 = vec3(0.0, uB, uC);\r\n    rect.id = 1;\r\n\r\n    Intersection p = toRect(rect, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToSphere(void) {\r\n    vec3 x = vec3(cos(uTheta),0.0,-sin(uTheta));\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(sin(uTheta),0.0,cos(uTheta));\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Sphere sphere;\r\n    sphere.p1 = vec3(0.0, 0.0, uH);\r\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    sphere.p3 = vec3(1.0, 0.0, uH);\r\n    sphere.id = 1;\r\n    sphere.radius = uR;\r\n\r\n    Intersection p = toSphere(sphere, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToCylinder(void) {\r\n    vec3 x = vec3(1.0, 0.0, 0.0);\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(0.0, 0.0, 1.0);\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Cylinder cylinder;\r\n    cylinder.p1 = vec3(0.0, 0.0, uH);\r\n    cylinder.p2 = vec3(uL, 0.0, uH);\r\n    cylinder.p3 = vec3(0.0, 0.0, uH+1.0);\r\n    cylinder.id = 1;\r\n    cylinder.radius = uR;\r\n\r\n    Intersection p = toCylinder(cylinder, ray);\r\n    return p.id;\r\n}\r\n\r\nint dsToTriangle(void) {\r\n    vec3 x = vec3(1.0, 0.0, 0.0);\r\n    vec3 y = vec3(0.0, 1.0, 0.0);\r\n    vec3 z = vec3(0.0, 0.0, 1.0);\r\n    Ray ray = fromDs(vec3(0.0, 0.0, 0.0), x, y, z);\r\n\r\n    Triangle tri;\r\n    tri.p1 = vec3(0.0, 0.0, uH);\r\n    tri.p2 = vec3(uL, 0.0, uH);\r\n    tri.p3 = vec3(uL, uL*tan(uTheta), uH);\r\n    tri.id = 1;\r\n\r\n    Intersection p = toTriangle(tri, ray);\r\n    return p.id;\r\n}\r\n\r\nint diskToDisk(void) {\r\n    Disk fd;\r\n    fd.p1 = vec3(0.0, 0.0, 0.0);\r\n    fd.p2 = vec3(0.0, 0.0, 1.0);\r\n    fd.p3 = vec3(1.0, 0.0, 0.0);\r\n    fd.id = 1;\r\n    fd.radius = uR1;\r\n    Ray ray = fromDisk(fd);\r\n\r\n    Disk td;\r\n    td.p1 = vec3(0.0, 0.0, uH);\r\n    td.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    td.p3 = vec3(1.0, 0.0, uH);\r\n    td.id = 2;\r\n    td.radius = uR2;\r\n\r\n    Intersection p = toDisk(td, ray);\r\n    return p.id;\r\n}\r\n\r\nint rectToRectParallel(void) {\r\n    Rectangle frect;\r\n    frect.p1 = vec3(0.0, 0.0, 0.0);\r\n    frect.p2 = vec3(uA, 0.0, 0.0);\r\n    frect.p3 = vec3(0.0, uB, 0.0);\r\n    frect.id = 1;\r\n    Ray ray = fromRect(frect);\r\n\r\n    Rectangle trect;\r\n    trect.p1 = vec3(0.0, 0.0, uC);\r\n    trect.p2 = vec3(uA, 0.0, uC);\r\n    trect.p3 = vec3(0.0, uB, uC);\r\n    trect.id = 2;\r\n\r\n    Intersection p = toRect(trect, ray);\r\n    return p.id;\r\n}\r\n\r\nint rectToRectVertical(void) {\r\n    Rectangle frect;\r\n    frect.p1 = vec3(0.0, 0.0, 0.0);\r\n    frect.p2 = vec3(uW, 0.0, 0.0);\r\n    frect.p3 = vec3(0.0, uL, 0.0);\r\n    frect.id = 1;\r\n    Ray ray = fromRect(frect);\r\n\r\n    Rectangle trect;\r\n    trect.p1 = vec3(0.0, 0.0, 0.0);\r\n    trect.p2 = vec3(0.0, uL, 0.0);\r\n    trect.p3 = vec3(0.0, 0.0, uH);\r\n    trect.id = 2;\r\n\r\n    Intersection p = toRect(trect, ray);\r\n    return p.id;\r\n}\r\n\r\nint sphereToRect(void) {\r\n    Sphere sphere;\r\n    sphere.p1 = vec3(0.0, 0.0, uH);\r\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    sphere.p3 = vec3(1.0, 0.0, uH);\r\n    sphere.id = 1;\r\n    sphere.radius = 1.0;\r\n    Ray ray = fromSphere(sphere);\r\n\r\n    Rectangle rect;\r\n    rect.p1 = vec3(0.0, 0.0, 0.0);\r\n    rect.p2 = vec3(uL1, 0.0, 0.0);\r\n    rect.p3 = vec3(0.0, uL2, 0.0);\r\n    rect.id = 2;\r\n\r\n    Intersection p = toRect(rect, ray);\r\n    return p.id;\r\n}\r\n\r\nint sphereToDisk(void) {\r\n    Sphere sphere;\r\n    sphere.p1 = vec3(0.0, 0.0, uH);\r\n    sphere.p2 = vec3(0.0, 0.0, uH+1.0);\r\n    sphere.p3 = vec3(1.0, 0.0, uH);\r\n    sphere.id = 1;\r\n    sphere.radius = 1.0;\r\n    Ray ray = fromSphere(sphere);\r\n\r\n    Disk disk;\r\n    disk.p1 = vec3(0.0, 0.0, 0.0);\r\n    disk.p2 = vec3(0.0, 0.0, 1.0);\r\n    disk.p3 = vec3(1.0, 0.0, 0.0);\r\n    disk.id = 2;\r\n    disk.radius = uR;\r\n\r\n    Intersection p = toDisk(disk, ray);\r\n    return p.id;\r\n}\r\n\r\nint sphereToCone(void) {\r\n    Sphere sphere;\r\n    sphere.p1 = vec3(0.0, 0.0, uR2/tan(uTheta)+uH+uR1);\r\n    sphere.p2 = vec3(0.0, 0.0, uR2/tan(uTheta)+uH+uR1+1.0);\r\n    sphere.p3 = vec3(1.0, 0.0, uR2/tan(uTheta)+uH+uR1);\r\n    sphere.id = 1;\r\n    sphere.radius = uR1;\r\n    Ray ray = fromSphere(sphere);\r\n\r\n    Cone cone;\r\n    cone.p1 = vec3(0.0, 0.0, 0.0);\r\n    cone.p2 = vec3(0.0, 0.0, uR2/tan(uTheta));\r\n    cone.p3 = vec3(1.0, 0.0, 0.0);\r\n    cone.id = 2;\r\n    cone.radius1 = uR2;\r\n    cone.radius2 = 0.0;\r\n\r\n    Intersection p = toCone(cone, ray);\r\n    return p.id;\r\n}\r\n\r\nint cylinderToCylinder(void) {\r\n    Cylinder fcylinder;\r\n    fcylinder.p1 = vec3(0.0, 0.0, 0.0);\r\n    fcylinder.p2 = vec3(0.0, 0.0, uH);\r\n    fcylinder.p3 = vec3(1.0, 0.0, 0.0);\r\n    fcylinder.id = 1;\r\n    fcylinder.radius = uR2;\r\n    Ray ray = fromCylinder(fcylinder);\r\n\r\n    Cylinder tcylinder;\r\n    tcylinder.p1 = vec3(0.0, 0.0, 0.0);\r\n    tcylinder.p2 = vec3(0.0, 0.0, uH);\r\n    tcylinder.p3 = vec3(1.0, 0.0, 0.0);\r\n    tcylinder.id = 2;\r\n    tcylinder.radius = uR1;\r\n\r\n    Intersection p = toCylinder(tcylinder, ray);\r\n    return p.id;\r\n}\r\n\r\nint diskToCylinder(void) {\r\n    Disk fd;\r\n    fd.p1 = vec3(0.0, 0.0, 0.0);\r\n    fd.p2 = vec3(0.0, 0.0, 1.0);\r\n    fd.p3 = vec3(1.0, 0.0, 0.0);\r\n    fd.id = 1;\r\n    fd.radius = uR;\r\n    Ray ray = fromDisk(fd);\r\n\r\n    Cylinder tcylinder;\r\n    tcylinder.p1 = vec3(0.0, 0.0, 0.0);\r\n    tcylinder.p2 = vec3(0.0, 0.0, uH);\r\n    tcylinder.p3 = vec3(1.0, 0.0, 0.0);\r\n    tcylinder.id = 2;\r\n    tcylinder.radius = uR;\r\n\r\n    Intersection p = toCylinder(tcylinder, ray);\r\n    return p.id;\r\n}\r\n\r\nint coneToDisk(void) {\r\n    Cone cone;\r\n    cone.p1 = vec3(0.0, 0.0, 0.0);\r\n    cone.p2 = vec3(0.0, 0.0, uH);\r\n    cone.p3 = vec3(1.0, 0.0, 0.0);\r\n    cone.id = 1;\r\n    cone.radius1 = uR;\r\n    cone.radius2 = 0.0;\r\n    Ray ray = fromCone(cone);\r\n    ray.rd = -1.0 * ray.rd;\r\n\r\n    Disk disk;\r\n    disk.p1 = vec3(0.0, 0.0, 0.0);\r\n    disk.p2 = vec3(0.0, 0.0, 1.0);\r\n    disk.p3 = vec3(1.0, 0.0, 0.0);\r\n    disk.id = 2;\r\n    disk.radius = uR;\r\n\r\n    Intersection p = toDisk(disk, ray);\r\n    return p.id;\r\n}\r\n\r\nvoid main(void) {\r\n    uint skip = uint(iSeed) * 100u;\r\n    skipMRG32k3a(skip);\r\n    int id;\r\n\r\n    switch (uCase) {\r\n        case 0:\r\n            id = dsToDisk();\r\n            break;\r\n        case 1:\r\n            id = dsToDiskOffsetParallel();\r\n            break;\r\n        // case 2:\r\n        //     id = dsToDiskOffsetVertical();\r\n        //     break;\r\n        case 3:\r\n            id = dsToRectParallel();\r\n            break;\r\n        case 4:\r\n            id = dsToRectVertical();\r\n            break;\r\n        case 5:\r\n            id = dsToSphere();\r\n            break;\r\n        case 6:\r\n            id = dsToCylinder();\r\n            break;\r\n        case 7:\r\n            id = dsToTriangle();\r\n            break;\r\n        case 10:\r\n            id = diskToDisk();\r\n            break;\r\n        case 11:\r\n            id = diskToCylinder();\r\n            break;\r\n        case 20:\r\n            id = rectToRectParallel();\r\n            break;\r\n        case 21:\r\n            id = rectToRectVertical();\r\n            break;\r\n        case 30:\r\n            id = sphereToRect();\r\n            break;\r\n        case 31:\r\n            id = sphereToDisk();\r\n            break;\r\n        // case 32:\r\n        //     id = sphereToCylinder();\r\n        //     break;\r\n        case 33:\r\n            id = sphereToCone();\r\n            break;\r\n        case 40:\r\n            id = cylinderToCylinder();\r\n            break;\r\n        case 50:\r\n            id = coneToDisk();\r\n            break;\r\n        // case 100:\r\n        //     id = triToTriArbitrary();\r\n        //     break;\r\n        // case 101:\r\n        //     id = rectTorectArbitrary();\r\n        //     break;\r\n        default:\r\n            id = 0;\r\n    }\r\n    \r\n    oCalc = float(id);\r\n    // oCalc = uR;\r\n}`;\n\n\n//# sourceURL=webpack://viewfactor/./src/vertex-shader.glsl.ts?");

/***/ }),

/***/ "./src/worker.ts":
/*!***********************!*\
  !*** ./src/worker.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nlet gl;\nlet program;\nlet tfBuffer;\nlet vao;\nlet tf;\nlet seed;\nonmessage = (evt) => {\n    let vf = 0.0;\n    switch (evt.data.type) {\n        case 'init':\n            init(evt);\n            postMessage({ 'type': 'init' });\n            break;\n        case 'ds-disk':\n            vf = dsDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-disk' });\n            break;\n        case 'ds-disk-parallel':\n            vf = dsDiskParallel(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-disk-parallel' });\n            break;\n        case 'ds-rect-p':\n            vf = dsRectP(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-rect-p' });\n            break;\n        case 'ds-rect-v':\n            vf = dsRectV(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-rect-v' });\n            break;\n        case 'ds-sphere':\n            vf = dsSphere(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-sphere' });\n            break;\n        case 'ds-cylinder':\n            vf = dsCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-cylinder' });\n            break;\n        case 'ds-triangle':\n            vf = dsTriangle(evt);\n            postMessage({ 'vf': vf, 'type': 'ds-triangle' });\n            break;\n        case 'disk-disk':\n            vf = diskDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'disk-disk' });\n            break;\n        case 'rect-rect-p':\n            vf = rectRectP(evt);\n            postMessage({ 'vf': vf, 'type': 'rect-rect-p' });\n            break;\n        case 'rect-rect-v':\n            vf = rectRectV(evt);\n            postMessage({ 'vf': vf, 'type': 'rect-rect-v' });\n            break;\n        case 'sphere-rect':\n            vf = sphereRect(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-rect' });\n            break;\n        case 'sphere-disk':\n            vf = sphereDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-disk' });\n            break;\n        case 'sphere-cone':\n            vf = sphereCone(evt);\n            postMessage({ 'vf': vf, 'type': 'sphere-cone' });\n            break;\n        case 'cylinder-cylinder':\n            vf = cylinderCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'cylinder-cylinder' });\n            break;\n        case 'disk-cylinder':\n            vf = diskCylinder(evt);\n            postMessage({ 'vf': vf, 'type': 'disk-cylinder' });\n            break;\n        case 'cone-disk':\n            vf = coneDisk(evt);\n            postMessage({ 'vf': vf, 'type': 'cone-disk' });\n            break;\n        default:\n            throw new Error('Unknown message type');\n    }\n};\n/**\n * Counts the number of occurrences of each element in a Float32Array\n * @param {Float32Array} arr - The array to count the occurrences of each element\n * @returns {number[]} An array containing the count of each element\n */\nfunction arrayCount(arr) {\n    let count = [];\n    for (let i = 0; i < arr.length; i++) {\n        let elm = Math.floor(arr[i]);\n        // if count[elm] is falsey, set 0 + 1, otherwise count[elm] + 1\n        count[elm] = (count[elm] || 0) + 1;\n    }\n    return count;\n}\nfunction draw() {\n    if (gl === null) {\n        throw new Error('Could not get WebGL2 context');\n    }\n    // Activate the program and bind the VAO\n    gl.useProgram(program);\n    gl.bindVertexArray(vao);\n    // Disable the rasterizer and bind the Transform Feedback\n    gl.enable(gl.RASTERIZER_DISCARD);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n    // Start the Transform Feedback and execute the draw call\n    gl.beginTransformFeedback(gl.POINTS);\n    gl.drawArrays(gl.POINTS, 0, seed.length);\n    gl.endTransformFeedback();\n    // Unbind the Transform Feedback and enable the rasterizer\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    gl.disable(gl.RASTERIZER_DISCARD);\n    // Unbind the VAO and deactivate the program\n    gl.bindVertexArray(null);\n    gl.useProgram(null);\n    // Create a Float32Array and get the data from the Transform Feedback buffer\n    let result = new Float32Array(seed.length);\n    gl.bindBuffer(gl.ARRAY_BUFFER, tfBuffer);\n    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, // byte offset into GPU buffer,\n    result);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return result;\n}\nfunction dsDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 0);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsDiskParallel(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 1);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsRectP(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 3);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsRectV(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 4);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsSphere(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 5);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 6);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction dsTriangle(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 7);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[1];\n}\nfunction diskDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 10);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction rectRectP(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 20);\n    let aLoc = gl.getUniformLocation(program, 'uA');\n    gl.uniform1f(aLoc, evt.data.a);\n    let bLoc = gl.getUniformLocation(program, 'uB');\n    gl.uniform1f(bLoc, evt.data.b);\n    let cLoc = gl.getUniformLocation(program, 'uC');\n    gl.uniform1f(cLoc, evt.data.c);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction rectRectV(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 21);\n    let lLoc = gl.getUniformLocation(program, 'uL');\n    gl.uniform1f(lLoc, evt.data.l);\n    let wLoc = gl.getUniformLocation(program, 'uW');\n    gl.uniform1f(wLoc, evt.data.w);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereRect(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 30);\n    let l1Loc = gl.getUniformLocation(program, 'uL1');\n    gl.uniform1f(l1Loc, evt.data.l1);\n    let l2Loc = gl.getUniformLocation(program, 'uL2');\n    gl.uniform1f(l2Loc, evt.data.l2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 31);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction sphereCone(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 33);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let thetaLoc = gl.getUniformLocation(program, 'uTheta');\n    gl.uniform1f(thetaLoc, evt.data.theta);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction cylinderCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 40);\n    let r1Loc = gl.getUniformLocation(program, 'uR1');\n    gl.uniform1f(r1Loc, evt.data.r1);\n    let r2Loc = gl.getUniformLocation(program, 'uR2');\n    gl.uniform1f(r2Loc, evt.data.r2);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction diskCylinder(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 11);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction coneDisk(evt) {\n    if (gl === null || program === null) {\n        throw new Error('gl or program is null');\n    }\n    gl.useProgram(program);\n    let caseLoc = gl.getUniformLocation(program, 'uCase');\n    gl.uniform1i(caseLoc, 50);\n    let rLoc = gl.getUniformLocation(program, 'uR');\n    gl.uniform1f(rLoc, evt.data.r);\n    let hLoc = gl.getUniformLocation(program, 'uH');\n    gl.uniform1f(hLoc, evt.data.h);\n    let array = draw();\n    gl.useProgram(null);\n    let count = arrayCount(array);\n    let vf = count.map((c) => (c / evt.data.nRays) || 0);\n    return vf[2];\n}\nfunction init(evt) {\n    const nRays = evt.data.nRays;\n    const canvas = evt.data.canvas;\n    gl = canvas.getContext('webgl2');\n    if (gl === null) {\n        throw new Error('Could not get WebGL2 context');\n    }\n    // Call the functions in an appropriate order\n    const vertexShader = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getVertexShader)(gl);\n    const fragmentShader = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getFragmentShader)(gl);\n    if (vertexShader === null || fragmentShader === null) {\n        throw new Error('Could not create shaders');\n    }\n    // Create a program\n    program = gl.createProgram();\n    if (program === null) {\n        throw new Error('Could not create program');\n    }\n    // Attach the shaders to this program\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.transformFeedbackVaryings(program, ['oCalc'], gl.SEPARATE_ATTRIBS);\n    gl.linkProgram(program);\n    // Check if the program linked successfully\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Could not initialize shaders');\n    }\n    // get the locations of the attributes in the related program\n    let iSeedLoc = gl.getAttribLocation(program, 'iSeed');\n    // create a vertex array object (vao)\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    // create the seed array [0, 1, 2, ..., nRays-1]\n    seed = Array.from({ length: nRays }, (_, i) => i);\n    // make a buffer for the seed in GPU memory\n    const seedBuf = gl.createBuffer();\n    // set the gl.ARRAY_BUFFER (buffer containing vertex attributes) to seedBuf \n    gl.bindBuffer(gl.ARRAY_BUFFER, seedBuf);\n    // copy the data from the seed array into the buffer\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(seed), gl.STATIC_DRAW);\n    // enable the attribute at location iSeedLoc \n    gl.enableVertexAttribArray(iSeedLoc);\n    // set the layout of the attribute at location iSeedLoc\n    gl.vertexAttribPointer(iSeedLoc, 1, // size (num components)\n    gl.FLOAT, // type of data in buffer\n    false, // normalize\n    0, // stride (0 = auto)\n    0);\n    gl.bindVertexArray(null);\n    // transform feedback object\n    tf = gl.createTransformFeedback();\n    // make buffers for output\n    tfBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, tfBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nRays), gl.DYNAMIC_COPY);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    // bind the buffers to the transform feedback\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, tfBuffer);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n}\n\n\n//# sourceURL=webpack://viewfactor/./src/worker.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worker.ts");
/******/ 	
/******/ })()
;